#!/usr/bin/env python3
import os, re, json, subprocess, datetime
from pathlib import Path
from typing import Optional, Dict
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field

# ---- repo layout ------------------------------------------------------------
ROOT = Path(__file__).resolve().parents[2]  # .../S1000D
SCHEMAS = ROOT / "schemas"
DMRL = ROOT / "publication_modules" / "DML-BWQ1-ATA57-00_EN-US.xml"
BREX_CANDIDATES = list((ROOT/"data_modules/descriptive").glob("DMC-BWQ1-*-022A-*-EN-US.xml"))
BREX_DM = BREX_CANDIDATES[0] if BREX_CANDIDATES else None
DRAFTS = ROOT / "gen_cms" / "drafts"
PRESETS = ROOT / "gen_cms" / "presets" / "prefill.json"
DRAFTS.mkdir(parents=True, exist_ok=True)

# ---- LLM provider abstraction ----------------------------------------------
class LLMProvider:
    def complete(self, system: str, prompt: str) -> str:
        raise NotImplementedError

class OpenAIProvider(LLMProvider):
    def __init__(self):
        self.api_key = os.getenv("OPENAI_API_KEY")
        self.model = os.getenv("GENCMS_OPENAI_MODEL","gpt-4o-mini")
        if not self.api_key:
            raise RuntimeError("OPENAI_API_KEY not set")
    def complete(self, system: str, prompt: str) -> str:
        # Lightweight call using requests (no extra deps)
        import requests
        url = os.getenv("OPENAI_BASE","https://api.openai.com/v1/chat/completions")
        headers = {"Authorization": f"Bearer {self.api_key}", "Content-Type":"application/json"}
        body = {
          "model": self.model,
          "messages": [{"role":"system","content":system},{"role":"user","content":prompt}],
          "temperature": float(os.getenv("GENCMS_TEMPERATURE","0.2")),
          "response_format": {"type":"text"}
        }
        r = requests.post(url, headers=headers, data=json.dumps(body), timeout=120)
        r.raise_for_status()
        return r.json()["choices"][0]["message"]["content"]

class MockProvider(LLMProvider):
    def complete(self, system: str, prompt: str) -> str:
        # Mock response that generates realistic S1000D content
        if "IC=040" in prompt:
            return """<content>
<description>
  <levelledPara>
    <title>General Description</title>
    <para>This data module provides a general description of the BWB-Q100 wing structure system.</para>
  </levelledPara>
  <levelledPara>
    <title>System Overview</title>
    <para>The wing structure system consists of the primary structural elements that form the wing assembly, including:</para>
    <randomList>
      <listItem><para>Primary wing spars and frames</para></listItem>
      <listItem><para>Wing skin panels and stiffeners</para></listItem>
      <listItem><para>Wing-to-fuselage attachment points</para></listItem>
    </randomList>
  </levelledPara>
  <levelledPara>
    <title>Functional Requirements</title>
    <para>The wing structure provides structural integrity and load transfer capability for the aircraft during all phases of flight operation.</para>
  </levelledPara>
</description>
</content>"""
        elif "IC=345" in prompt or "IC=350" in prompt:
            return """<content>
<description>
  <levelledPara>
    <title>Test Procedure</title>
    <para>This data module describes the test procedure for verifying system functionality.</para>
  </levelledPara>
  <levelledPara>
    <title>Prerequisites</title>
    <para>Before performing this test, ensure the following conditions are met:</para>
    <randomList>
      <listItem><para>System power is available</para></listItem>
      <listItem><para>All safety precautions are observed</para></listItem>
      <listItem><para>Test equipment is properly calibrated</para></listItem>
    </randomList>
  </levelledPara>
  <levelledPara>
    <title>Acceptance Criteria</title>
    <para>The test is successful when all specified parameters are within acceptable limits and no anomalous conditions are observed.</para>
  </levelledPara>
</description>
</content>"""
        else:
            return """<content>
<description>
  <levelledPara>
    <title>System Information</title>
    <para>This data module contains information generated by GenCMS for the specified system component.</para>
  </levelledPara>
  <levelledPara>
    <title>Content Overview</title>
    <para>The content has been automatically generated based on the provided objectives and constraints, following S1000D standards and BWQ1 BREX requirements.</para>
  </levelledPara>
</description>
</content>"""

def pick_provider() -> LLMProvider:
    name = os.getenv("GENCMS_PROVIDER","mock").lower()
    if name == "openai":
        return OpenAIProvider()
    elif name == "mock":
        return MockProvider()
    raise RuntimeError(f"Unknown provider: {name}")

# ---- tiny XML helpers -------------------------------------------------------
def find_brex_rules() -> str:
    if not BREX_DM or not BREX_DM.exists():
        return ""
    txt = BREX_DM.read_text(errors="ignore")
    # crude extract of <levelledPara> text as "rules"
    return "\n".join(re.findall(r"<para>(.*?)</para>", txt, re.S))

def csdb_rules() -> str:
    f = ROOT / "metadata" / "csdb_rules.xml"
    return f.read_text(errors="ignore") if f.exists() else ""

def cir_glossary() -> str:
    # optional: include terminology CIR for consistent wording
    f = ROOT / "common_information" / "terminology" / "CIR-BWQ1-00001.xml"
    return f.read_text(errors="ignore") if f.exists() else ""

def ic_family_to_bucket(ic: str) -> str:
    i = int(ic) if ic.isdigit() else -1
    if ic in {"040","042","034","050","051","052","053","054","055","056"}: return "descriptive"
    if ic in {"310","345","350"}: return "descriptive"     # tests kept simple here
    if 500 <= i <= 599: return "procedural"
    if 600 <= i <= 699: return "procedural"
    if 700 <= i <= 799: return "procedural"
    if ic == "420" or (421 <= i <= 428): return "fault"
    if ic in {"900","910"}: return "ipd"
    return "descriptive"

def schema_for_bucket(bucket: str) -> str:
    # You can split to proced.xsd / fault.xsd later; for now use descript.xsd
    return "descript.xsd" if bucket in {"descriptive","procedural","fault","ipd"} else "descript.xsd"

def dm_filename(dm: Dict[str,str], lang="EN", ctry="US") -> str:
    return ("DMC-{mic}-{sdc}-{sc}-{ssc}-{sssc}-{ac}-{dc}{dcv}-{ic}{icv}-{iloc}-"
            f"{lang}-{ctry}.xml").format(**dm)

def dm_template(schema: str, title: str, info: str, dm: Dict[str,str]) -> str:
    # BREX ref always included
    brex_ref = ""
    if BREX_DM:
        # extract dmCode attributes from filename path of BREX (rough)
        brex_ref = f"""
      <brexDmRef>
        <dmRef><dmRefIdent>
          <dmCode modelIdentCode="{dm['mic']}" systemDiffCode="A"
                  systemCode="00" subSystemCode="00" subSubSystemCode="00"
                  assyCode="00" disassyCode="00A" disassyCodeVariant="A"
                  infoCode="022" infoCodeVariant="A" itemLocationCode="D"/>
        </dmRefIdent></dmRef>
      </brexDmRef>"""
    return f"""<?xml version="1.0" encoding="UTF-8"?>
<dmodule xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="../../schemas/{schema}">
  <identAndStatusSection>
    <dmAddress>
      <dmIdent>
        <dmCode modelIdentCode="{dm['mic']}" systemDiffCode="{dm['sdc']}"
                systemCode="{dm['sc']}" subSystemCode="{dm['ssc']}" subSubSystemCode="{dm['sssc']}"
                assyCode="{dm['ac']}" disassyCode="{dm['dc']}" disassyCodeVariant="{dm['dcv']}"
                infoCode="{dm['ic']}" infoCodeVariant="{dm['icv']}" itemLocationCode="{dm['iloc']}"/>
        <language languageIsoCode="en" countryIsoCode="US"/>
        <issueInfo issueNumber="001" inWork="01"/>
      </dmIdent>
      <dmAddressItems>
        <issueDate year="{datetime.date.today().year}" month="{datetime.date.today().month:02d}" day="{datetime.date.today().day:02d}"/>
        <dmTitle>
          <techName>BWB-Q100</techName>
          <infoName>{title}</infoName>
        </dmTitle>
      </dmAddressItems>
    </dmAddress>
    <dmStatus issueType="new">
      <security securityClassification="01"/>
      <dataRestrictions><restrictionInfo>
        <classificationString>INTERNALâ€“EVIDENCE-REQUIRED</classificationString>
      </restrictionInfo></dataRestrictions>{brex_ref}
      <responsiblePartnerCompany><enterpriseName>AMPEL360</enterpriseName></responsiblePartnerCompany>
    </dmStatus>
  </identAndStatusSection>
  <content>
    <description>
      <levelledPara>
        <title>{title}</title>
        <para>{info}</para>
      </levelledPara>
      <!-- GenCMS will expand more levelledPara blocks below -->
    </description>
  </content>
</dmodule>"""

# ---- request/response models -----------------------------------------------
class GenerateReq(BaseModel):
    dmKey: str = Field(..., description="Full DMC key string (from IETP)")
    objective: str
    constraints: Optional[str] = ""
    seed_outline: Optional[str] = ""
    style_tone: Optional[str] = "concise, aerospace technical, S1000D voice"
    safety_focus: Optional[str] = ""  # e.g., H2 safety for 57-20

class GenerateResp(BaseModel):
    xml: str
    draft_path: Optional[str]
    filename: str
    bucket: str
    schema: str

class PromoteReq(BaseModel):
    dmKey: str
    draft_path: str

class PrefillReq(BaseModel):
    dmKey: str = Field(..., description="Full DMC key string (from IETP)")

class PrefillResp(BaseModel):
    objective: str
    constraints: str
    seed_outline: str
    safety_focus: str

class RefineReq(BaseModel):
    dmKey: str = Field(..., description="Full DMC key string (from IETP)")
    xml_content: str = Field(..., description="Generated XML content to refine")
    feedback: Optional[str] = ""

class RefineResp(BaseModel):
    xml: str
    improvements: str
    filename: str

# ---- helper functions -------------------------------------------------------
def load_prefill_templates() -> dict:
    """Load prefill templates from JSON file"""
    if PRESETS.exists():
        try:
            return json.loads(PRESETS.read_text())
        except (json.JSONDecodeError, IOError):
            pass
    return {"defaults": {}, "ic_overrides": {}, "subsystem_modifiers": {}}

def get_dm_requirement_comment(dm_key: str) -> str:
    """Extract requirement comment from DMRL for this DM key"""
    if not DMRL.exists():
        return ""
    
    try:
        import xml.etree.ElementTree as ET
        dmrl = defusedxml.etree.ElementTree.parse(DMRL).getroot()
        for req in dmrl.findall(".//dmRequirement"):
            code = req.find("./dmRefIdent/dmCode")
            if code is not None:
                # Build the key from dmCode attributes
                built_key = f"DMC-{code.get('modelIdentCode')}-{code.get('systemDiffCode')}-{code.get('systemCode')}-{code.get('subSystemCode')}-{code.get('subSubSystemCode')}-{code.get('assyCode')}-{code.get('disassyCode')}{code.get('disassyCodeVariant')}-{code.get('infoCode')}{code.get('infoCodeVariant')}-{code.get('itemLocationCode')}-EN-US"
                if built_key == dm_key:
                    comment = req.find("./reqComment")
                    return comment.text if comment is not None else ""
    except:
        pass
    return ""

def generate_prefill_content(dm: Dict[str, str]) -> PrefillResp:
    """Generate context-aware prefill content based on DM key"""
    templates = load_prefill_templates()
    defaults = templates.get("defaults", {})
    ic_overrides = templates.get("ic_overrides", {})
    subsys_modifiers = templates.get("subsystem_modifiers", {})
    
    # Extract components
    ic = dm["ic"]
    subsys = dm["ssc"] 
    dm_key = f"DMC-{dm['mic']}-{dm['sdc']}-{dm['sc']}-{dm['ssc']}-{dm['sssc']}-{dm['ac']}-{dm['dc']}{dm['dcv']}-{dm['ic']}{dm['icv']}-{dm['iloc']}-EN-US"
    
    # Get requirement comment from DMRL
    req_comment = get_dm_requirement_comment(dm_key)
    
    # Get IC-specific overrides
    ic_data = ic_overrides.get(ic, {})
    subsys_data = subsys_modifiers.get(subsys, {})
    
    # Build tokens for template substitution
    tokens = {
        "DM_KEY": dm_key,
        "ATA": f"ATA-57-{subsys}",
        "SUBSYS": subsys,
        "IC": ic,
        "IC_NAME": ic_data.get("name", "content"),
        "SAFETY": subsys_data.get("safety_additions", defaults.get("safety", "")),
        "REQ_COMMENT": req_comment
    }
    
    # Apply template substitution
    def substitute_tokens(template: str) -> str:
        result = template
        for token, value in tokens.items():
            result = result.replace(f"{{{token}}}", value)
        return result
    
    # Build response using IC overrides or defaults
    objective = substitute_tokens(ic_data.get("objective", defaults.get("objective", "Provide {IC_NAME} for {ATA}")))
    constraints = substitute_tokens(ic_data.get("constraints", defaults.get("constraints", "")))
    outline = ic_data.get("outline", defaults.get("outline", ""))
    safety = ic_data.get("safety", defaults.get("safety", "")) 
    
    # Add subsystem-specific safety additions
    if subsys_data.get("safety_additions"):
        if safety:
            safety += f" {subsys_data['safety_additions']}"
        else:
            safety = subsys_data["safety_additions"]
    
    return PrefillResp(
        objective=objective,
        constraints=constraints,
        seed_outline=outline,
        safety_focus=safety
    )

# ---- FastAPI ----------------------------------------------------------------
app = FastAPI(title="GenCMS for BWQ1 ATA-57")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify actual origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/health")
def health():
    return {"ok": True}

def parse_dm_key(dmKey: str) -> Dict[str,str]:
    # DMC-BWQ1-A-57-10-00-00-00A-040A-D-EN-US  -> parts
    p = dmKey.split("-")
    if len(p) < 12 or not p[0].startswith("DMC"):
        raise HTTPException(400, f"Bad dmKey: {dmKey}")
    return {
        "mic":  p[1],
        "sdc":  p[2],
        "sc":   p[3],
        "ssc":  p[4],
        "sssc": p[5],
        "ac":   p[6],
        "dc":   p[7][:-1],
        "dcv":  p[7][-1],
        "ic":   p[8][:-1],
        "icv":  p[8][-1],
        "iloc": p[9],
    }

def compose_prompt(dm: Dict[str,str], req: GenerateReq) -> (str, str):
    # System prompt + user prompt; inject BREX + CSDB rules + CIR terminology
    brex = find_brex_rules()
    rules = csdb_rules()
    terms = cir_glossary()

    # Info-code guidance summary (ATA-57 mapping)
    ic = dm["ic"]
    mapping = {
      "040":"Description overview",
      "034":"Technical data / physical breakdown",
      "042":"Functional description",
      "345":"System/functional test",
      "350":"Structural/operational check",
    }.get(ic, "Follow S1000D structure for this info code.")

    sys = f"""You are a senior S1000D author. Output ONLY valid XML fragments for the <content> section of a data module.
Follow S1000D Issue 6.0, the program BREX and CSDB rules. Keep tone: {req.style_tone}.
NEVER invent unsafe steps; include warnings/cautions ONLY if appropriate to the IC.
When lists are needed, use <randomList><listItem><para>â€¦</para></listItem>â€¦</randomList>.
Do not include XML declaration or <dmodule> wrapper; I will insert your content into a template.
"""

    user = f"""Context:
- MIC={dm['mic']} ATA-57-{dm['ssc']} IC={dm['ic']} ({mapping})
- Objective: {req.objective}
- Constraints: {req.constraints}
- Safety focus: {req.safety_focus}

Seed outline (optional):
{req.seed_outline}

BREX excerpts:
{brex[:3000]}

CSDB rules:
{rules[:2000]}

Terminology (CIR):
{terms[:1500]}

Write 2â€“4 <levelledPara> sections, with clear <title>, and use <randomList> only when helpful.
If IC is tests (345/350), include acceptance criteria. If IC is 5xx/7xx, write procedural voice with pre-reqs/safety.
Return only the XML for <content> (from <description> or procedure content as applicable)."""
    return sys, user

@app.post("/generate", response_model=GenerateResp)
def generate(req: GenerateReq):
    dm = parse_dm_key(req.dmKey)
    bucket = ic_family_to_bucket(dm["ic"])
    schema = schema_for_bucket(bucket)

    provider = pick_provider()
    sys_msg, user_msg = compose_prompt(dm, req)
    draft = provider.complete(sys_msg, user_msg).strip()

    # Sanitize: keep only inside <content>â€¦ if the model over-returned
    if "<content" in draft:
        draft = re.sub(r"^[\s\S]*?<content", "<content", draft, flags=re.S)
        draft = re.sub(r"</content>.*$", "</content>", draft, flags=re.S)
    # Ensure at least a <description> exists
    if "<description" not in draft:
        draft = f"<content><description>{draft}</description></content>"

    title = f"Auto-generated draft (IC {dm['ic']})"
    shell = dm_template(schema, title, "Draft created by GenCMS.", dm)
    # splice the model output into <content>â€¦</content>
    xml = re.sub(r"<content>[\s\S]*</content>", draft, shell, count=1)

    fname = dm_filename(dm)
    dpath = DRAFTS / fname
    dpath.write_text(xml, encoding="utf-8")

    return GenerateResp(xml=xml, draft_path=str(dpath), filename=fname, bucket=bucket, schema=schema)

@app.post("/promote")
def promote(req: PromoteReq):
    dm = parse_dm_key(req.dmKey)
    bucket = ic_family_to_bucket(dm["ic"])
    target_dir = ROOT / "data_modules" / bucket
    target_dir.mkdir(parents=True, exist_ok=True)
    src = Path(req.draft_path)
    if not src.exists():
        raise HTTPException(404, "draft_path not found")
    dst = target_dir / src.name
    dst.write_text(src.read_text())
    # regenerate indices if tool exists
    gen = ROOT / "validation" / "validators" / "generate_indices.py"
    if gen.exists():
        subprocess.run(["python3", str(gen)], cwd=str(gen.parent), check=False)
    return {"ok": True, "path": str(dst.relative_to(ROOT))}

@app.post("/prefill", response_model=PrefillResp)
def prefill(req: PrefillReq):
    """Generate context-aware prefill content based on DM key"""
    dm = parse_dm_key(req.dmKey)
    return generate_prefill_content(dm)

@app.post("/refine", response_model=RefineResp)
def refine(req: RefineReq):
    """Refine generated XML content with improvements"""
    dm = parse_dm_key(req.dmKey)
    provider = pick_provider()
    
    # Create a refinement prompt
    sys_msg = """You are a senior S1000D technical reviewer. Review the provided XML content and suggest improvements.
Focus on S1000D compliance, clarity, completeness, and adherence to BREX rules.
Return ONLY the improved XML content for the <content> section (no wrapper elements).
Make minimal but meaningful improvements while preserving the core structure."""
    
    user_msg = f"""Review and improve this S1000D XML content for {req.dmKey}:

{req.xml_content}

Additional feedback: {req.feedback}

Return the improved XML content only."""
    
    try:
        improved_xml = provider.complete(sys_msg, user_msg).strip()
        
        # Sanitize: keep only inside <content>â€¦ if the model over-returned
        if "<content" in improved_xml:
            improved_xml = re.sub(r"^[\s\S]*?<content", "<content", improved_xml, flags=re.S)
            improved_xml = re.sub(r"</content>[\s\S]*$", "</content>", improved_xml, flags=re.S)
        
        # Ensure at least a <description> exists
        if "<description" not in improved_xml and "<procedure" not in improved_xml:
            improved_xml = f"<content><description>{improved_xml}</description></content>"
        
        fname = dm_filename(dm)
        improvements = "Content refined with improved structure, clarity, and S1000D compliance."
        
        return RefineResp(
            xml=improved_xml,
            improvements=improvements,
            filename=fname
        )
    except Exception as e:
        raise HTTPException(500, f"Refinement failed: {str(e)}")